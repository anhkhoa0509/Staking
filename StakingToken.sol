

pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@chainlink/contracts/src/v0.8/KeeperCompatible.sol";

contract Staking is Ownable,KeeperCompatibleInterface {
    using SafeMath for uint256;
  
    address[][] internal stakeholders;
    IERC20 private tokenReward;

    // Address owner contract
    address public admin;
    uint256 public totalDakRewardInContract;
    uint public counter;

   
    // Time staking
    mapping(uint256=>mapping(address=>uint256)) internal startStakingTime;

    mapping(uint256=>mapping(address=>uint256)) internal endStakingTime;
    

 
    mapping(uint256=> mapping(address => uint256)) internal stakes;
    
    mapping(uint256=> mapping(address => bool)) internal isStake;

    mapping(uint256=> mapping(address => uint256)) internal rewards;

    mapping(uint256=> mapping(address => uint256)) internal tokenRewardWithdraw;

    mapping(address=>uint256) internal totalDak;

    mapping(uint256=>mapping(address => uint256)) internal unLocks;
    
    struct Staking{
        address owner;
        uint256 time;
        uint256 totalStakes;
        uint interestRate;
        string typeCoin;
        uint256 id;
        uint256 timeUnlocks;
        address[] userStaking;
    }


    Staking[] public Stakings;


      constructor (IERC20 token)  {
        tokenReward = token;
        admin = msg.sender;
    }
    // ---------- STAKES ----------
    function remove(uint256 _index,uint256 _id) public {
        require(_index < Stakings[_id].userStaking.length, "index out of bound");

        for (uint i = _index; i < Stakings[_id].userStaking.length - 1; i++) {
            Stakings[_id].userStaking[i] = Stakings[_id].userStaking[i + 1];
        }
        Stakings[_id].userStaking.pop();
    }

    function checkUpkeep(bytes calldata  checkData ) external view override returns (bool upkeepNeeded, bytes memory /* performData */) {
        for(uint256 i = 0 ; i < Stakings.length; i++){
            for(uint256 j = 0 ; j<Stakings[i].userStaking.length;j++){
                if(block.timestamp > timeStaked(Stakings[i].userStaking[j],i)){
                     upkeepNeeded = block.timestamp > timeStaked(Stakings[i].userStaking[j],i);
                }
            }
        }
    }
   
     function performUpkeep(bytes calldata  performData ) external override {
       for(uint256 i = 0 ; i < Stakings.length; i++){
            for(uint256 j = 0 ; j<Stakings[i].userStaking.length;j++){
                if(block.timestamp > timeStaked(Stakings[i].userStaking[j],i)){
                    counter ++;
                     if(unLocks[i][Stakings[i].userStaking[j]] > 1){
                         withdrawRawardPart(i,Stakings[i].userStaking[j]);
                     }else{
                         withdrawReward(i,Stakings[i].userStaking[j]);
                         remove(j,i);
                     }
                  
                }
            }
        }
        // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function
    }

   
    function createStaking(uint256 _time, uint _interestRate,string memory _typeCoin,uint256 _timeUnlocks) public onlyOwner{
        address[] memory addressUser;
        Stakings.push(
            Staking(msg.sender,_time,0,_interestRate,_typeCoin,Stakings.length,_timeUnlocks,addressUser)
        );
    }

    function getStaking() public view returns (address[] memory){
         uint256 sum;
          for(uint256 i = 0 ; i < Stakings.length; i++){
              sum = sum.add(Stakings[i].userStaking.length);
          }
        address[] memory result =  new address[](sum);
        uint256 index = 0;
        for (uint256 i = 0; i < Stakings.length ; i++) {
            for(uint256 j = 0; j < Stakings[i].userStaking.length ; j++){
                result[index] = Stakings[i].userStaking[j];
                index++;
            }
                
            }
        return result;
    }


    function getTimeSuccessReward(address _userAdress,uint256 _id) public view returns (uint256[] memory){
        uint256 number = (endStakingTime[_id][_userAdress] - startStakingTime[_id][_userAdress])/Stakings[_id].timeUnlocks;
        uint256[] memory result = new uint256[](number);
        uint256 temp =  startStakingTime[_id][_userAdress];
        for (uint256 i = 0; i < number ; i++) {
                temp = temp.add(Stakings[_id].timeUnlocks);
                result[i] = temp;
            }
        return result;
    }

    /**
     * @notice A method for a stakeholder to create a stake.
     * @param _stake The size of the stake to be created, 1 _stake = 0.01 ETH
     *
     */
     
    function createStake(uint256 _stake,uint256 _id, uint256 _rStake,uint256 _rDak,uint256 _time) public payable{
        require( !isStake[_id][msg.sender], "The address is staking");

        require(_stake  > 0 &&  msg.value > 0 && _stake == msg.value, "Cannot staking value 0");

        isStake[_id][msg.sender] = true;
        
        Stakings[_id].userStaking.push(msg.sender);
        
        startStakingTime[_id][msg.sender] = block.timestamp;

        endStakingTime[_id][msg.sender] = block.timestamp.add(_time);
 
        unLocks[_id][msg.sender] = _time.div(Stakings[_id].timeUnlocks);
      
        stakes[_id][msg.sender] = msg.value;

        uint256 sumReward = calculateReward(_stake,_id,_rStake,_rDak,_time);

        tokenRewardWithdraw[_id][msg.sender] =(sumReward * Stakings[_id].timeUnlocks).div(_time);
        
        rewards[_id][msg.sender] = sumReward;

        Stakings[_id].totalStakes =  Stakings[_id].totalStakes.add(msg.value);

    }


    function geTotaltUserInStaking(uint256 _id) public view returns(address [] memory){
        return Stakings[_id].userStaking;
    }

    function addStake(uint256 _stake,uint256 _id, uint256 _rStake,uint256 _rDak,uint256 _time) public payable{
        require(_stake  > 0 &&  msg.value > 0 && _stake == msg.value, "Cannot staking value 0");
        
        require(isStake[_id][msg.sender] , "User not staking");

        require(_time > unLocks[_id][msg.sender] , "The remaining time is larger than the extra staking time");

        require(isStake[_id][msg.sender] , "User not staking");
        
        unLocks[_id][msg.sender] = _time.div(Stakings[_id].timeUnlocks);
        
        endStakingTime[_id][msg.sender] = endStakingTime[_id][msg.sender].add(Stakings[_id].time);
        
        stakes[_id][msg.sender] = stakes[_id][msg.sender].add(msg.value);

        Stakings[_id].totalStakes =  Stakings[_id].totalStakes.add(msg.value);
        
        uint256 sumReward = calculateReward(stakes[_id][msg.sender],_id,_rStake,_rDak,_time);

        rewards[_id][msg.sender] = sumReward;

        tokenRewardWithdraw[_id][msg.sender] =(sumReward * Stakings[_id].timeUnlocks).div(_time);

    }

    function calculateReward(uint256 _stake,uint256 _id, uint256 _rStake,uint256 _rDak,uint256 _time) public view returns(uint256){
        return (_stake * _rStake * Stakings[_id].interestRate*_time**10*18).div(_rDak*100*Stakings[_id].time);
    }

    function getUnblock(address _userAdress,uint256 _id) public view returns(uint256){
        return  startStakingTime[_id][msg.sender].add((unLocks[_id][_userAdress] + 1) * Stakings[_id].timeUnlocks);
    }

    function getTotalUnblock(address _userAdress,uint256 _id) public view returns(uint256){
        return unLocks[_id][_userAdress];
    }

     function getBalanceStaking(uint256 _id) public view returns(uint256){
        return Stakings[_id].totalStakes;
    }

  
    function getBalanceUserStake(address _userAdress,uint256 _id) public view returns(uint){
        return  stakes[_id][_userAdress];
    }


    function getTokenUserReward(address _userAdress,uint256 _id) public view returns(uint){
        return rewards[_id][_userAdress];
    }
  

    function getTimeStaking(address _stakeholder,uint256 _id)
        public
        view
        returns (uint256)
    {
        return endStakingTime[_id][_stakeholder];
    }

 
  
    // ---------- REWARDS ----------



    function getUserReward(address _userAdress, uint256 _id) public view returns(uint256){
        return  tokenRewardWithdraw[_id][_userAdress];
    }

    function timeStaked(address _userAdress, uint256 _id) public view returns(uint256){
        uint256 time =  startStakingTime[_id][_userAdress];
        uint256 timeStake = (endStakingTime[_id][_userAdress] - startStakingTime[_id][_userAdress]).div(Stakings[_id].timeUnlocks);
       return time.add((timeStake - unLocks[_id][_userAdress])*Stakings[_id].timeUnlocks);
    }

    function withdrawRawardPart(uint256 _id,address _userAdress) public {
        require(isStake[_id][_userAdress] , "User not staking");

        require(endStakingTime[_id][_userAdress] > 0, "not staking yet");

        require(unLocks[_id][_userAdress] > 1, "not enough draws");
        
        uint256 reward = tokenRewardWithdraw[_id][_userAdress];

        tokenReward.transferFrom(admin, _userAdress,reward);

        totalDak[_userAdress] = totalDak[_userAdress] + reward;

        totalDakRewardInContract = totalDakRewardInContract + reward;

        unLocks[_id][_userAdress] = unLocks[_id][_userAdress] - 1;
    }

    function getTotalDakReward() public view returns(uint256){
        return totalDakRewardInContract;
    }

    /**
     * @notice A method to allow a stakeholder to withdraw his rewards.
     */
    function withdrawReward(uint256 _id,address _userAdress) public payable{
        require(isStake[_id][_userAdress] , "User not staking");

        require(endStakingTime[_id][_userAdress] > 0, "not staking yet");

        require(unLocks[_id][_userAdress] == 1, "not enough draws");

        uint amountToTransfer = getBalanceUserStake(_userAdress,_id);

        address payable withdrawTo = payable(_userAdress);

        withdrawTo.transfer(amountToTransfer);

        Stakings[_id].totalStakes = Stakings[_id].totalStakes.sub(amountToTransfer);

        uint256 reward = tokenRewardWithdraw[_id][_userAdress];

        tokenReward.transferFrom(admin, _userAdress, reward);

        totalDakRewardInContract = totalDakRewardInContract.add(reward);
        
        // reset initialization value
        isStake[_id][_userAdress] = false;

        rewards[_id][_userAdress] = 0;

        stakes[_id][_userAdress] = 0;

        endStakingTime[_id][_userAdress] = 0;

        unLocks[_id][_userAdress] = 0;
    }

   
}
